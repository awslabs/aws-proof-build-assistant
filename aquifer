#!/usr/bin/env python3
import argparse
import subprocess
import os
import re
import sys
import json

TOOL_NAME = "aquifer"
COMPILE_CMD_NAME = "/compile_commands.json"

def build():
    # Set up environment
    print("Work in Progress: Print list of all files to build\n")
    aquiferpath = os.path.dirname(__file__)
    cwd = os.getcwd()
    sourcename = os.path.basename(cwd)

    builddirname = sourcename + "-build"
    builddirpath = os.path.join(aquiferpath, builddirname)

    subprocess.call("mkdir " + builddirname, shell=True, cwd=aquiferpath) # avoid warning?

    # Run the cmake command and output compilation_commands.json file
    cmake_cmd = ["cmake", "-GNinja", "-DCMAKE_BUILD_TYPE=Debug", \
        "-DCMAKE_PREFIX_PATH=/usr/local/Cellar/openssl@1.1/1.1.1g", \
        "-DCMAKE_EXPORT_COMPILE_COMMANDS=1"] #ADJUST ACCORDING TO PROGRAM
    cmake_cmd.append(cwd)

    subprocess.call(cmake_cmd, cwd=builddirpath)

    # Load the generated compilation commands
    cmp_cmd_file = open(builddirpath + COMPILE_CMD_NAME)
    cmp_cmd = json.load(cmp_cmd_file)


    # extract relevant information 
    dct = {}
    for cmd in cmp_cmd:
        filename = cmd['file']
        if not filename in dct:
            dct[filename] = {}
        else:
            print("DUPLICATE FOR    ", filename)

    # create json file with relevant information
    outjson = json.dumps(dct, indent=4)
    db_file_name = "/builddb.json"
    f = open(aquiferpath + db_file_name, "w")
    f.write(outjson)
    f.close()

    print("\nCreated build data base at {}".format(db_file_name))

    

def print_file(file):
    print("print is not yet implemented")

def render():
    print("render is not yet implemented")


def main():
    description = TOOL_NAME + " tool: helping developers get build information for cource files they want to test."

    parser = argparse.ArgumentParser(description=description)

    parser.add_argument("command", nargs=1, default = "", help="run command for {}. Available command: build, print <SRC_FILE>, render".format(TOOL_NAME))
    parser.add_argument("argument", nargs="?", default = "", help="<SRC_FILE> argument for the print command")
    arguments = parser.parse_args()

    valid_commands = ["build", "print", "render"]
    cmd = arguments.command[0]
    arg = arguments.argument

    if not cmd in valid_commands:
        print("Please input a valid command: " + str(valid_commands))

    if cmd == "print" and arg == "" :
        print("Please add the file to print build information for: print <SRC_FILE>. Exiting.")
        return
    
    if cmd != "print" and arg != "" :
        print("Too many arguments. Exiting.")
        return

    if cmd == "build":
        build()

    if cmd == "print":
        print_file(arg)

    if cmd == "render":
        render()




if __name__== "__main__":
    main()