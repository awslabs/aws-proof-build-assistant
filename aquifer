#!/usr/bin/env python3
"""
aquifer tool:  helping developers get build information for source files they want to test.
"""

import argparse
import subprocess
import os
import json
import logging

TOOL_NAME = "aquifer"
COMPILE_CMD_NAME = "compile_commands.json"
OUT_DB_NAME = "builddb.json"

def build(args):
    """ Generate a json build database for the current project. No return"""
    # Set up environment
    print("Work in Progress: Print list of all files to build\n")
    aquiferpath = os.path.dirname(__file__)
    cwd = os.getcwd()
    sourcename = os.path.basename(cwd)

    builddirname = sourcename + "-build"
    builddirpath = os.path.join(aquiferpath, builddirname)
    if not os.path.exists(builddirpath):
        os.mkdir(builddirpath) # avoid warning?

    # Run the cmake command and output compilation_commands.json file
    cmake_cmd = ["cmake", "-GNinja", "-DCMAKE_BUILD_TYPE=Debug",
                 "-DCMAKE_PREFIX_PATH=/usr/local/Cellar/openssl@1.1/1.1.1g",
                 "-DCMAKE_EXPORT_COMPILE_COMMANDS=1"] #TODO ADJUST ACCORDING TO PROGRAM
    cmake_cmd.append(cwd)
    subprocess.call(cmake_cmd, cwd=builddirpath)

    # Load the generated compilation commands
    comp_cmds = None
    with open(os.path.join(builddirpath, COMPILE_CMD_NAME), "r") as handle:
        comp_cmds = json.load(handle)

    # Extract relevant information
    build_db = {"files":{}}
    for comp_cmd in comp_cmds:
        file_dict = {}
        # file name
        file_path = comp_cmd['file']
        file_name = os.path.basename(file_path)
        file_dict["name"] = file_name
        file_dir = os.path.dirname(file_path)
        file_dict["directory"] = file_dir

        #command
        command = comp_cmd['command'].split()
        command_include_dirs = []
        command_defines = {}
        for cmd_tup in enumerate(command):
            cmd_ind = cmd_tup[0]
            next_arg = None if cmd_ind == len(command)-1 else command[cmd_ind+1]
            include = get_flag_arg("-I", command[cmd_ind], next_arg)
            if include:
                command_include_dirs.append(include)
            include = get_flag_arg("-isystem", command[cmd_ind], next_arg)
            if include:
                command_include_dirs.append(include)
            define = get_flag_arg("-D", command[cmd_ind], next_arg)
            if define:
                define_pair = get_define_pair(define)
                command_defines[define_pair[0]] = define_pair[1]

        #get includes and defines from file
        file_includes_raw = []
        file_includes = []
        file_defines = {}
        with open(file_path, "r") as file_handle:
            for line in file_handle:

                #includes
                if line.strip().startswith("#include"):
                    split = line.split()
                    if len(split) != 2:
                        logging.warning("Malformed #include in %s : %s", file_name, line[:-1])
                    else:
                        file_2_include = split[1]
                        first = file_2_include[0]
                        last = file_2_include[-1]
                        local_include = (first == "\"" and last == "\"")
                        global_include = (first == "<" and last == ">")
                        malformed = not local_include and not global_include
                        if malformed:
                            logging.warning("Malformed #include in %s : %s", file_name, line[:-1])
                        else:
                            file_includes_raw.append(file_2_include)
                            include_name = file_2_include[1:-1]
                            found_path = False
                            if local_include:
                                potential_path = os.path.join(file_dir, include_name)
                                if os.path.exists(potential_path):
                                    found_path = True
                                    file_includes.append(potential_path)
                            if not found_path:
                                for included_dir in command_include_dirs:
                                    potential_path = os.path.join(included_dir, include_name)
                                    if os.path.exists(potential_path):
                                        file_includes.append(potential_path)
                                        found_path = True
                                        break
                            if not found_path:
                                file_includes.append(include_name)
                                if local_include:
                                    logging.warning("#include not found for %s : %s", file_name, line[:-1])

                #defines TODO
                if line.strip().startswith("#define"):
                    split = line.split()
                    val = None
                    if len(split) < 2 or len(split) > 3:
                        logging.warning("Malformed #define in %s : %s", file_name, line[:-1])
                    if len(split) == 3:
                        val = split[2]
                    file_defines[split[1]] = val

        file_dict["include-files_raw"] = file_includes_raw
        file_dict["include-files"] = file_includes
        file_dict["include_directories"] = command_include_dirs
        file_dict["define-in-file"] = file_defines
        file_dict["define-in-cmd"] = command_defines

        if file_name in build_db:
            logging.warning("Duplicate for %s", file_path)
        else:
            build_db.get("files")[file_name] = file_dict


    # create json file with relevant information
    outjson = json.dumps(build_db, indent=4)
    with open(os.path.join(aquiferpath, OUT_DB_NAME), "w") as handle:
        print(outjson, file=handle)
    print("\nCreated build data base at {}".format(OUT_DB_NAME))


def get_flag_arg(flag, arg, next_arg):
    """ if string corresponds to correct flag, return corresponding argument. """
    if len(arg) < len(flag):
        return None
    if len(arg) == len(flag) and arg == flag:
        return next_arg
    if len(arg) > len(flag) and arg[:len(flag)] == flag:
        return arg[len(flag):]


def get_define_pair(statement, seperator="="):
    """ for a define statement, return a key-value pair. """
    split = statement.split(seperator)
    val = "1"
    if len(split) > 1:
        val = split[1]
    return (split[0], val)


def print_file(args):
    """ Print build information for a selected file. No return. """

    path_to_file = args.file_path
    print("print is not yet implemented - file {}".format(path_to_file))


def render(args):
    """ Generate a web interface containing build data for all fioles. No return. """

    print("render is not yet implemented")


def main():
    """ Main function """

    logging.basicConfig(filename=os.path.dirname(__file__) + "/out.log", level=logging.DEBUG)

    parser = argparse.ArgumentParser(description=__doc__)
    subparser = parser.add_subparsers(help="Available commands for {}".format(TOOL_NAME))

    # build command
    parser_build = subparser.add_parser('build', help="Generate a build database \
        for the current project.")
    parser_build.set_defaults(func=build)

    # print command
    parser_print = subparser.add_parser('print', help="Print build information \
        for a selected file.")
    parser_print.add_argument("file_path", default="",
                              help="path to file to output info for.")
    parser_print.set_defaults(func=print_file)

    # render command
    parser_render = subparser.add_parser('render', help="Generate a web interface \
        containing {} data.".format(TOOL_NAME))
    parser_render.set_defaults(func=render)

    # parse and run
    arguments = parser.parse_args()
    arguments.func(arguments)


if __name__ == "__main__":
    main()
