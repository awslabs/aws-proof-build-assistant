#!/usr/bin/env python3
"""
aquifer tool:  helping developers get build information for source files they want to test.
"""

import argparse
import subprocess
import os
import json
import logging
import sys

TOOL_NAME = "aquifer"
TOOL_PATH = os.path.dirname(__file__)
COMPILE_CMD_NAME = "compile_commands.json"

PROJECT_NAME = os.path.basename(os.getcwd())
OUT_DB_NAME = "aquifer-db.json"

def build(args):
    """ Generate a json build database from given compile commands.
    If not compile commands path given, generate compile commands.
    No return"""

    comp_cmds_path = args.compile_commands_json_path
    # if no compile commands path is set
    if comp_cmds_path == "":
        # Set up environment
        cwd = os.getcwd()
        builddirname = PROJECT_NAME + "-build"
        builddirpath = os.path.join(TOOL_PATH, builddirname)
        if not os.path.exists(builddirpath):
            os.mkdir(builddirpath) # avoid warning?

        # Run the cmake command and output compilation_commands.json file
        cmake_cmd = ["cmake", "-GNinja", "-DCMAKE_BUILD_TYPE=Debug",
                     "-DCMAKE_PREFIX_PATH=/usr/local/Cellar/openssl@1.1/1.1.1g",
                     "-DCMAKE_EXPORT_COMPILE_COMMANDS=1"] # TODO Currently specific to S2N
        cmake_cmd.append(cwd)
        subprocess.call(cmake_cmd, cwd=builddirpath)
        comp_cmds_path = os.path.join(builddirpath, COMPILE_CMD_NAME)

    # Load the generated compilation commands, if possible
    if not os.path.exists(comp_cmds_path):
        print("Specified path does not point to an existing file: {}".format(comp_cmds_path))
        sys.exit()

    # compilation commands location
    comp_cmds_dir = os.path.dirname(comp_cmds_path)
    out_db_path = os.path.join(comp_cmds_dir, OUT_DB_NAME)

    comp_cmds = None
    with open(comp_cmds_path, "r") as handle:
        comp_cmds = json.load(handle)

    # Extract relevant information
    build_db = {"files":{}}
    for comp_cmd in comp_cmds:
        file_dict = {}
        # file name. TODO Only consider non-test files.
        file_path = str(comp_cmd['file'])
        # if file_path.endswith("test.c"):
        #     continue

        file_name = os.path.basename(file_path)
        file_dict["name"] = file_name
        file_dir = os.path.dirname(file_path)
        file_dict["directory"] = file_dir

        #command
        command = comp_cmd['command'].split()
        command_include_dirs = []
        command_defines = {}
        for cmd_tup in enumerate(command):
            cmd_ind = cmd_tup[0]
            next_arg = None if cmd_ind == len(command)-1 else command[cmd_ind+1]
            include = get_flag_arg("-I", command[cmd_ind], next_arg)
            if include:
                command_include_dirs.append(include)
            include = get_flag_arg("-isystem", command[cmd_ind], next_arg)
            if include:
                command_include_dirs.append(include)
            define = get_flag_arg("-D", command[cmd_ind], next_arg)
            if define:
                define_pair = get_define_pair(define)
                command_defines[define_pair[0]] = define_pair[1]
   
        # file_dict["include-files_raw"] = file_includes_raw
        file_dict["include_directories"] = command_include_dirs
        file_dict["defines-in-cmd"] = command_defines

        if file_name in build_db:
            logging.warning("Duplicate for %s", file_path)
        else:
            build_db.get("files")[file_name] = file_dict


    # create json file with relevant information
    outjson = json.dumps(build_db, indent=4)
    with open(out_db_path, "w") as handle:
        print(outjson, file=handle)
    print("\nCreated build database at {}".format(out_db_path))


def get_flag_arg(flag, arg, next_arg):
    """ if string corresponds to correct flag, return corresponding argument. """
    if len(arg) < len(flag):
        return None
    if len(arg) == len(flag) and arg == flag:
        return next_arg
    if len(arg) > len(flag) and arg[:len(flag)] == flag:
        return arg[len(flag):]


def get_define_pair(statement, seperator="="):
    """ for a define statement, return a key-value pair. """
    split = statement.split(seperator)
    val = "1"
    if len(split) > 1:
        val = split[1]
    return (split[0], val)


def print_file(args):
    """ Print build information for a selected file. No return. """

    path_to_file = args.file_path
    print("print is not yet implemented - file {}".format(path_to_file))


def render(args):
    """ Generate a web interface containing build data for all fioles. No return. """

    print("render is not yet implemented")


def main():
    """ Main function """

    logging.basicConfig(filename=os.path.dirname(__file__) + "/out.log", level=logging.DEBUG)

    # parse arguments
    parser = argparse.ArgumentParser(description=__doc__)
    subparser = parser.add_subparsers(help="Available commands for {}".format(TOOL_NAME))

    # build command
    parser_build = subparser.add_parser('build', help="Generate a build database \
        for the current project.")
    parser_build.add_argument("compile_commands_json_path", nargs='?', default="",
                              help="path to compile_commands json file.")
    parser_build.set_defaults(func=build)

    # print command
    parser_print = subparser.add_parser('print', help="Print build information \
        for a selected file.")
    parser_print.add_argument("file_path", default="",
                              help="path to file to output info for.")
    parser_print.set_defaults(func=print_file)

    # render command
    parser_render = subparser.add_parser('render', help="Generate a web interface \
        containing {} data.".format(TOOL_NAME))
    parser_render.set_defaults(func=render)

    # parse and run
    arguments = parser.parse_args()
    arguments.func(arguments)


if __name__ == "__main__":
    main()
