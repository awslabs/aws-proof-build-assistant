#!/usr/bin/env python3
"""
aquifer tool:  helping developers get build information for source files they want to test.
"""

import argparse
import subprocess
import os
import json
import logging
import sys

TOOL_NAME = "aquifer"
TOOL_PATH = os.path.dirname(__file__)
COMPILE_CMD_NAME = "compile_commands.json"

PROJECT_NAME = os.path.basename(os.getcwd())
OUT_DB_NAME = "Makefile.aquifer"

MAKE_FILEUT = "FILEUT"
MAKE_FUNCUT = "FUNCUT"
MAKE_INCLUDE = "INC"
MAKE_DEFINE = "DEF"

def build(args):
    """ Generate a json build database from given compile commands.
    If not compile commands path given, generate compile commands.
    No return"""

    comp_cmds_path = args.compile_commands_json_path
    # if no compile commands path is set
    if comp_cmds_path == "":
        # Set up environment
        cwd = os.getcwd()
        builddirname = PROJECT_NAME + "-build"
        builddirpath = os.path.join(TOOL_PATH, builddirname)
        if not os.path.exists(builddirpath):
            os.mkdir(builddirpath) # avoid warning?

        # Run the cmake command and output compilation_commands.json file
        cmake_cmd = ["cmake", "-GNinja", "-DCMAKE_BUILD_TYPE=Debug",
                     "-DCMAKE_PREFIX_PATH=/usr/local/Cellar/openssl@1.1/1.1.1g",
                     "-DCMAKE_EXPORT_COMPILE_COMMANDS=1"] # TODO Currently specific to S2N
        cmake_cmd.append(cwd)
        subprocess.call(cmake_cmd, cwd=builddirpath)
        comp_cmds_path = os.path.join(builddirpath, COMPILE_CMD_NAME)

    # Load the generated compilation commands, if possible
    if not os.path.exists(comp_cmds_path):
        print("Specified path does not point to an existing file: {}".format(comp_cmds_path))
        sys.exit()

    # get compilation commands
    comp_cmds_dir = os.path.dirname(comp_cmds_path)
    out_db_path = os.path.join(comp_cmds_dir, OUT_DB_NAME)
    comp_cmds = None
    with open(comp_cmds_path, "r") as handle:
        comp_cmds = json.load(handle)

    # Extract relevant information
    all_file_names = {}
    with open(out_db_path, "w") as output:
        for comp_cmd in comp_cmds:
            # file name. TODO Only consider non-test files.
            file_path = str(comp_cmd['file'])
            # if file_path.endswith("test.c"):
            #     continue

            file_name = os.path.basename(file_path)

            #command
            command_split = comp_cmd['command'].split()
            command_include_dirs = []
            command_defines = []
            for cmd_tup in enumerate(command_split):
                cmd_ind = cmd_tup[0]
                next_arg = "" if cmd_ind == len(command_split)-1 else command_split[cmd_ind+1]
                include = get_flag_arg("-I", command_split[cmd_ind], next_arg)
                if include:
                    command_include_dirs.append(include)
                include = get_flag_arg("-isystem", command_split[cmd_ind], next_arg)
                if include:
                    command_include_dirs.append(include)
                define = get_flag_arg("-D", command_split[cmd_ind], next_arg)
                if define:
                    command_defines.append(define)

            # write makefile
            if file_name in all_file_names:
                path1 = file_path
                path2 = all_file_names[file_name]
                logging.warning("Clashing file name: %s  <>  %s", path1, path2)
            else:
                all_file_names[file_name] = file_path
                print("ifeq (%s,\"%s\")" % (make_value(MAKE_FILEUT), file_name), file=output)

                #iterate through includes
                for inc in command_include_dirs:
                    print("  %s" % add_to_var("INC", inc), file=output)

                #iterate through defines
                for define in command_defines:
                    print("  %s" % add_to_var("DEF", define), file=output)

                print("endif\n", file=output)

    print("\nCreated aquifer Makefile at {}".format(out_db_path))


def add_to_var(var, term):
    """ return correct MAKE syntax for adding a value to a variable. """
    return "%s += %s" % (var, term)


def make_value(var):
    """ return MAKE syntax for accessing a variable value """
    return "$(" + str(var) + ")"


def get_flag_arg(flag, arg, next_arg):
    """ if string corresponds to correct flag, return corresponding argument. """
    if len(arg) < len(flag):
        return None
    if len(arg) == len(flag) and arg == flag:
        return arg + " " + next_arg
    if len(arg) > len(flag) and arg[:len(flag)] == flag:
        return arg


def print_file(args):
    """ Print build information for a selected file. No return. """

    path_to_file = args.file_path
    print("print is not yet implemented - file {}".format(path_to_file))


def render(args):
    """ Generate a web interface containing build data for all fioles. No return. """

    print("render is not yet implemented")


def main():
    """ Main function """

    logging.basicConfig(filename=os.path.dirname(__file__) + "/out.log", level=logging.DEBUG)

    # parse arguments
    parser = argparse.ArgumentParser(description=__doc__)
    subparser = parser.add_subparsers(help="Available commands for {}".format(TOOL_NAME))

    # build command
    parser_build = subparser.add_parser('build', help="Generate a build database \
        for the current project.")
    parser_build.add_argument("compile_commands_json_path", nargs='?', default="",
                              help="path to compile_commands json file.")
    parser_build.set_defaults(func=build)

    # print command
    parser_print = subparser.add_parser('print', help="Print build information \
        for a selected file.")
    parser_print.add_argument("file_path", default="",
                              help="path to file to output info for.")
    parser_print.set_defaults(func=print_file)

    # render command
    parser_render = subparser.add_parser('render', help="Generate a web interface \
        containing {} data.".format(TOOL_NAME))
    parser_render.set_defaults(func=render)

    # parse and run
    arguments = parser.parse_args()
    arguments.func(arguments)


if __name__ == "__main__":
    main()
